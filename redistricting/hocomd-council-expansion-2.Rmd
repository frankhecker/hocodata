---
title: "Howard County Council Expansion, Part 2"
author: "Frank Hecker"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    fig_width: 8
    fig_height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

In this document I display a map of the Howard County Council districts
produced by running the AutoRedistrict application to create three council
districts electing five members per district using ranked choice voting.
I also show racial and (estimated) party vote share by district.

For those readers unfamiliar with the [R statistical software][r] and
the additional [Tidyverse software][tv] I use to manipulate and plot
data, I’ve included some additional explanation of various steps.  For
more information check out the various [ways to learn more about the
Tidyverse][learn].

[r]: https://www.r-project.org/
[tv]: https://www.tidyverse.org/
[learn]: https://www.tidyverse.org/learn/

## Setup and data preparation

### Libraries

I use the following packages for the following purposes:

* tidyverse: do general data manipulation.
* sf: manipulate geospatial data.
* tigris: get data on roads.
* tools. compute MD5 checksums.

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(tigris)
library(tools)
```

### Data sources

I use data from the following sources; see the References section
below for more information:

* Boundaries for Howard County precincts are from the shapefile produced
  by part 1 of this analysis. These are the precincts used in the 2018
  general election for county council.
* Assignment of precincts to new districts is from the AutoRedistrict
  program.

### Reading in and preparing the data

I first read in the shapefile containing Howard County precinct boundaries
and related data, as produced by part 1 of this analysis.

```{r redistricting_sf}
redistricting_sf <- st_read("redistricting-input.shp")
```

I then read in the data on new districts produced by the
AutoRedistrict application. I create a new factor variable
`District` from the original variable `Distrct`. I leave the
`Precnct` variable as is because it will be used as common field
with the geospatial data table. I retain only
those two fields, since all the other fields are
duplicated in the geospatial data table.

```{r new_districts}
district_names <- tribble(
  ~Distrct, ~District,
  1, "West",
  2, "Southeast",
  3, "Northeast"
)

new_districts_df <- read_csv("redistricting-output.csv",
                             show_col_types = FALSE) %>%
  left_join(district_names, by = "Distrct") %>%
  mutate(District = as.factor(District)) %>%
  select(District, Precnct)
```

To help orient readers as to the locations of the district boundaries, I also want any maps generated to also display major roads in Howard County that correspond in whole or in part to
district or precinct boundaries. I use the tigris function roads() to return geometry for all Howard County roads.

Because I don’t need or want to display each and every Howard County road, I use the RTTYP and FULLNAME variables to filter the results to retain only major roads (interstate and U.S. highways) and significant minor roads (Maryland state routes and roads with “Parkway” in their names). I store the geometry for each in separate variables, so that I can plot them at different widths.

```{r roads}
all_roads <- roads(state = "MD", county = "Howard County", class = "sf", progress_bar = FALSE)

major_roads_geo <- all_roads %>%
  filter(RTTYP %in% c("I", "U")) %>%
  st_geometry()

minor_roads_geo <- all_roads %>%
  filter(RTTYP == "S" | str_detect(FULLNAME, "Pkwy")) %>%
  st_geometry()
```

### Analysis

I plot the new districts along with the major (and some minor) roads
to show how the new districts would relate to existing communities in
Howard County.

Although this was not specified explicitly as part of the auto-redistricting
process, the new districts very nicely divide the county into three
"communities of interest":

* Core Columbia and southeastern Howard, including Savage and North Laurel.
* Ellicott City and northeastern Howard, including Elkridge.
* Western Howard, including River Hill.

```{r plot}
palette <- c("#E69F00", "#56B4E9", "#009E73")

redistricting_sf %>%
  left_join(new_districts_df, by = "Precnct") %>%
  ggplot(aes(fill = District, geometry = geometry)) +
  geom_sf(size = 0) +
  scale_fill_manual(values = palette) +
  geom_sf(data = major_roads_geo, color = "white", size = 1.0, fill = NA) +
  geom_sf(data = minor_roads_geo, color = "white", size = 0.5, fill = NA) +
  labs(title="Districts for 15-Member Council with Ranked Choice Voting",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning",
         "\n  Maryland Board of Elections",
         "\nCreated using the AutoRedistrict application and tidyverse R package"
       )
  ) +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0)) +
  theme(axis.ticks = element_blank(), axis.text = element_blank()) +
  theme(panel.background = element_blank())
```

The precinct-level data in `redistricting_sf` contains population figures
by race. I combine the precinct-level data (in `redistricting_sf`) with the assignment
of precincts to council districts produced by the AutoRedistrict application
(in `new_districts_sf`), and then drop the geometry for the shapefile boundaries.

```{r table}
district_data <- redistricting_sf %>%
  left_join(new_districts_df, by = "Precnct") %>%
  st_drop_geometry()
```

I compute the racial breakdowns for each district.

```{r racial}
racial_breakdown <- district_data %>%
  group_by(District) %>%
  summarize(Adj_Ppl = sum(Adj_Ppl),
            Ad_NH_W = sum(Ad_NH_W),
            Ad_NH_B = sum(Ad_NH_B),
            Ad_NH_A = sum(Ad_NH_A),
            Ad_NH_R = sum(Ad_NH_R),
            Adj_H_O = sum(Adj_H_O)) %>%
  mutate(White = round(100 * Ad_NH_W / Adj_Ppl),
         Black = round(100 * Ad_NH_B / Adj_Ppl),
         Asian = round(100 * Ad_NH_A / Adj_Ppl),
         Multiracial = round(100 * Ad_NH_R / Adj_Ppl),
         Hispanic = round(100 * Adj_H_O / Adj_Ppl)) %>%
  select(District, White, Black, Asian, Multiracial, Hispanic)
```

I plot the racial breakdown by district.

```{r ggplot_racial}
palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2")

quota = 100 / 6

racial_breakdown %>%
  gather(key = "Race", value = Vote_Pct, White:Hispanic) %>%
  mutate(Race = fct_relevel(Race, c("White", "Black", "Asian", "Multiracial", "Hispanic"))) %>%
  ggplot(mapping = aes(x = District, y = Vote_Pct, fill = Race)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = palette) +
  geom_hline(mapping = aes(yintercept = quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 2 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 3 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 4 * quota), color = "gray", linetype = "dashed") +
  labs(title="Expanded County Council District Population Percentage By Race",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning",
         "\n  Maryland Board of Elections",
         "\nCreated using the AutoRedistrict application and tidyverse R package"
       )
  ) +
  ylab("Population (%)") +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0)) +
  theme_bw()
```

Compute the party breakdown for each district.

```{r party}
party_breakdown <- district_data %>%
  mutate(Votes = CEx.DEM + CEx.REP + CCn.DEM + CCn.REP,
         Dem_Votes = CEx.DEM + CCn.DEM,
         Rep_Votes = CEx.REP + CCn.REP) %>%
  group_by(District) %>%
  summarize(Votes = sum(Votes),
            Dem_Votes = sum(Dem_Votes),
            Rep_Votes = sum(Rep_Votes)) %>%
  mutate(Democratic = round(100 * Dem_Votes / Votes),
         Republican = round(100 * Rep_Votes / Votes)) %>%
  select(District, Democratic, Republican)
```

I plot the party breakdowns by district.

```{r ggplot_party}
palette <- c("#0072B2", "#D55E00")

party_breakdown %>%
  gather(key = "Party", value = Vote_Pct, Democratic:Republican) %>%
  mutate(Party = fct_relevel(Party, c("Democratic", "Republican"))) %>%
  ggplot(mapping = aes(x = District, y = Vote_Pct, fill = Party)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = palette) +
  geom_hline(mapping = aes(yintercept = quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 2 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 3 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 4 * quota), color = "gray", linetype = "dashed") +
  ylab("Estimated Vote (%)") +
  labs(title="Expanded County Council District Estimated Vote by Party",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning",
         "\n  Maryland Board of Elections",
         "\nCreated using the AutoRedistrict application and tidyverse R package"
       )
  ) +
  theme_bw() +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0))
```


## Appendix

### Caveats

To be written.

### References

To be written.

### Suggestions for others

To be written.

### Environment

I used the following R environment in doing the analysis above:

```{r}
sessionInfo()
```

### Source code

You can find the source code for this analysis and others at my
[hocodata public code repository][hd].  This document and its source
code are available for unrestricted use, distribution and modification
under the terms of the [Creative Commons CC0 1.0 Universal (CC0 1.0)
Public Domain Dedication][cc0].  Stated more simply, you’re free to do
whatever you’d like with it.

[hd]: https://gitlab.com/frankhecker/hocodata
[cc0]: https://creativecommons.org/publicdomain/zero/1.0/
