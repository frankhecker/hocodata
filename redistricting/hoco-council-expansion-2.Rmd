---
title: "Howard County Council Expansion, Part 2"
author: "Frank Hecker"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    fig_width: 8
    fig_height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

In this document I display a map of the Howard County Council
districts produced by running the Auto-Redistrict application to
create fifteen council districts electing one member per district
using ranked choice voting.  I also show racial/ethnic population
percentages by district and (estimated) party vote share by
district.

For those readers unfamiliar with the [R statistical software][r] and
the additional [Tidyverse software][tv] I use to manipulate and plot
data, I’ve included some additional explanation of various steps.  For
more information check out the various [ways to learn more about the
Tidyverse][learn].

[r]: https://www.r-project.org/
[tv]: https://www.tidyverse.org/
[learn]: https://www.tidyverse.org/learn/

## Setup and data preparation

### Libraries

I use the following packages for the following purposes:

* tidyverse: do general data manipulation.
* sf: manipulate geospatial data.
* tigris: get data on roads.
* tools: compute MD5 checksums.
* knitr: display data in tabular format.

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(tigris)
library(tools)
library(knitr)
```

### Data sources

I use data from the following sources; see the References section of
part 1 for more information:

* Boundaries for Howard County precincts are from the shapefile produced
  by part 1 of this analysis. These are the precincts used in the 2018
  general election for county council.
* Assignment of precincts to new districts is from the Auto-Redistrict
  program.

### Reading in and preparing the data

I first read in the shapefile containing Howard County precinct
boundaries and related data, as produced by part 1 of this analysis.

```{r redistricting_sf}
redistricting_sf <- st_read("redistricting-input.shp")
```

I then read in the data on new districts produced by the
Auto-Redistrict application. I create a new factor variable
`District` based on the original numeric variable `Distrct`.
I leave the `Precnct` variable as is because it will be used as a
common field with the geospatial data table. I retain only the
`District` and `Precnct` fields, since all the other fields are
duplicated in the geospatial data table originally used as input to
the Auto-Redistrict application.

```{r new_districts}

new_districts_tb <- read_csv("redistricting-output-15-districts.csv",
                             show_col_types = FALSE) %>%
  mutate(District = as.factor(Distrct)) %>%
  select(District, Precnct)
```

To help orient readers as to the locations of the district boundaries,
I also want any maps generated to also display major roads in Howard
County that correspond in whole or in part to district or precinct
boundaries. I use the tigris function `roads()` to return geometry for
all Howard County roads.

Because I don’t need or want to display each and every Howard County
road, I use the RTTYP and FULLNAME variables to filter the results to
retain only major roads (interstate and U.S. highways) and significant
minor roads (Maryland state routes and roads with “Parkway” in their
names). I store the geometry for each in separate variables so that I
can plot them at different widths.

```{r roads}
all_roads <- roads(state = "MD", county = "Howard County", class = "sf", progress_bar = FALSE)

major_roads_geo <- all_roads %>%
  filter(RTTYP %in% c("I", "U")) %>%
  st_geometry()

minor_roads_geo <- all_roads %>%
  filter(RTTYP == "S" | str_detect(FULLNAME, "Pkwy")) %>%
  st_geometry()
```

### Analysis

I plot the new districts along with the major (and some minor) roads
to show how the new districts would relate to existing communities in
Howard County.

```{r plot}
palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2",
             "#D55E00", "#CC79A7", "#999999", "#E69F00", "#56B4E9",
             "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

redistricting_sf %>%
  left_join(new_districts_tb, by = "Precnct") %>%
  ggplot(aes(fill = District, geometry = geometry)) +
  geom_sf(size = 0) +
  scale_fill_manual(values = palette) +
  geom_sf(data = major_roads_geo, color = "white", size = 1.0, fill = NA) +
  geom_sf(data = minor_roads_geo, color = "white", size = 0.5, fill = NA) +
  labs(title="Example 15-District Howard County Council",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning, 2020 Redistricting Data",
         "\n  Maryland Board of Elections, 2018 General Election Results",
         "\n  Howard County GIS Division, Precinct Boundaries",
         "\nCreated using the Auto-Redistrict application and tidyverse R package"
       )
  ) +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0)) +
  theme(axis.ticks = element_blank(), axis.text = element_blank()) +
  theme(panel.background = element_blank()) +
  theme(legend.position = "none")
```

The precinct-level data in `redistricting_sf` contains population
figures by race. I combine the precinct-level data (in
`redistricting_sf`) with the assignment of precincts to council
districts produced by the Auto-Redistrict application (in
`new_districts_sf`), and then drop the geometry for the precinct
boundaries.

```{r table}
district_data <- redistricting_sf %>%
  left_join(new_districts_tb, by = "Precnct") %>%
  st_drop_geometry()
```

I compute the racial/ethnic breakdowns for each district.

```{r racial}
racial_breakdown <- district_data %>%
  group_by(District) %>%
  summarize(Adj_Ppl = sum(Adj_Ppl),
            Ad_NH_W = sum(Ad_NH_W),
            Ad_NH_B = sum(Ad_NH_B),
            Ad_NH_A = sum(Ad_NH_A),
            Ad_NH_R = sum(Ad_NH_R),
            Adj_H_O = sum(Adj_H_O)) %>%
  mutate(`NH White` = round(100 * Ad_NH_W / Adj_Ppl),
         `NH Black` = round(100 * Ad_NH_B / Adj_Ppl),
         `NH Asian` = round(100 * Ad_NH_A / Adj_Ppl),
         `NH Multiracial` = round(100 * Ad_NH_R / Adj_Ppl),
         Hispanic = round(100 * Adj_H_O / Adj_Ppl)) %>%
  select(District, `NH White`, `NH Black`, `NH Asian`, `NH Multiracial`, Hispanic)
```

I plot the racial/ethnic breakdowns by district.

```{r ggplot_racial}
palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2")

racial_breakdown %>%
  gather(key = "Race", value = Pop_Pct, `NH White`:Hispanic) %>%
  mutate(Race = fct_relevel(Race, c("NH White", "NH Black", "NH Asian", "NH Multiracial", "Hispanic"))) %>%
  ggplot(mapping = aes(x = District, y = Pop_Pct, fill = Race)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = palette) +
  labs(title="15-District Howard County Council Population Percentage By Race/Ethnicity",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning, 2020 Redistricting Data",
         "\n  Maryland Board of Elections, 2018 General Election Results",
         "\n  Howard County GIS Division, Precinct Boundaries",
         "\nCreated using the Auto-Redistrict application and tidyverse R package"
       ),
       fill = "Race/Ethnicity"
  ) +
  ylab("Population (%)") +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0)) +
  theme_bw()
```

I also print the same data in the form of a table:

```{r kable_racial_breakdown}
racial_breakdown %>%
  kable(caption = "15-District Howard County Council Population Percentage By Race/Ethnicity")
```

I compute the party breakdown for each district.

```{r party}
party_breakdown <- district_data %>%
  mutate(Votes = CEx.DEM + CEx.REP + CCn.DEM + CCn.REP,
         Dem_Votes = CEx.DEM + CCn.DEM,
         Rep_Votes = CEx.REP + CCn.REP) %>%
  group_by(District) %>%
  summarize(Votes = sum(Votes),
            Dem_Votes = sum(Dem_Votes),
            Rep_Votes = sum(Rep_Votes)) %>%
  mutate(Democratic = round(100 * Dem_Votes / Votes),
         Republican = round(100 * Rep_Votes / Votes)) %>%
  select(District, Democratic, Republican)
```

I plot the party breakdowns by district.

```{r ggplot_party}
palette <- c("#0072B2", "#D55E00")

party_breakdown %>%
  gather(key = "Party", value = Vote_Pct, Democratic:Republican) %>%
  mutate(Party = fct_relevel(Party, c("Democratic", "Republican"))) %>%
  ggplot(mapping = aes(x = District, y = Vote_Pct, fill = Party)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = palette) +
  ylab("Estimated Vote (%)") +
  labs(title="15-District Howard County Council Estimated Party Vote Share",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning, 2020 Redistricting Data",
         "\n  Maryland Board of Elections, 2018 General Election Results",
         "\nCreated using the Auto-Redistrict application and tidyverse R package"
       )
  ) +
  theme_bw() +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0))
```

I also print the same data in the form of a table:

```{r kable_party_breakdown}
party_breakdown %>%
  kable(caption = "15-District Howard County Council Estimated Party Vote Share")
```

## Appendix

### Caveats

See part 1.

### References

See part 1.

### Suggestions for others

See part 1.

### Environment

I used the following R environment in doing the analysis above:

```{r}
sessionInfo()
```

### Source code

You can find the source code for this analysis and others at my
[hocodata public code repository][hd].  This document and its source
code are available for unrestricted use, distribution and modification
under the terms of the [Creative Commons CC0 1.0 Universal (CC0 1.0)
Public Domain Dedication][cc0].  Stated more simply, you’re free to do
whatever you’d like with it.

[hd]: https://github.com/frankhecker/hocodata
[cc0]: https://creativecommons.org/publicdomain/zero/1.0/
