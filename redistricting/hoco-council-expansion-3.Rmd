---
title: "Howard County Council Expansion, Part 2"
author: "Frank Hecker"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    fig_width: 8
    fig_height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

In this document I display a map of the Howard County Council
districts produced by running the Auto-Redistrict application to
create three council districts electing five members per district
using ranked choice voting.  I also show racial/ethnic and (estimated)
party vote share by district.

For those readers unfamiliar with the [R statistical software][r] and
the additional [Tidyverse software][tv] I use to manipulate and plot
data, I’ve included some additional explanation of various steps.  For
more information check out the various [ways to learn more about the
Tidyverse][learn].

[r]: https://www.r-project.org/
[tv]: https://www.tidyverse.org/
[learn]: https://www.tidyverse.org/learn/

## Setup and data preparation

### Libraries

I use the following packages for the following purposes:

* tidyverse: do general data manipulation.
* sf: manipulate geospatial data.
* tigris: get data on roads.
* tools. compute MD5 checksums.

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(tigris)
library(tools)
```

### Data sources

I use data from the following sources; see the References section of
part 1 for more information:

* Boundaries for Howard County precincts are from the shapefile produced
  by part 1 of this analysis. These are the precincts used in the 2018
  general election for county council.
* Assignment of precincts to new districts is from the Auto-Redistrict
  program.

### Reading in and preparing the data

I first read in the shapefile containing Howard County precinct
boundaries and related data, as produced by part 1 of this analysis.

```{r redistricting_sf}
redistricting_sf <- st_read("redistricting-input.shp")
```

The district numbers generated by the Auto-Redistrict application are
arbitrary and bear no relationship to the current council district
numbering scheme. To reduce confusion and improve clarity I create a
table `district_name_tb` that maps the district numbers to the
locations of the districts within Howard County.

I then read in the data on new districts produced by the
Auto-Redistrict application. I use the table `district_name_tb` to add
a new variable `District` containing the district names. (I make that
variable into a so-called “factor” variable to simplify creating the
graphs below.)

I leave the `Precnct` variable as is because it will be used as a
common field with the geospatial data table. I retain only the
`District` and `Precnct` fields, since all the other fields are
duplicated in the geospatial data table originally used as input to
the Auto-Redistrict application.

```{r new_districts}
district_name_tb <- tribble(
  ~Distrct, ~District,
  1, "Northeast",
  2, "Southeast",
  3, "West"
)

new_districts_tb <- read_csv("redistricting-output.csv",
                             show_col_types = FALSE) %>%
  left_join(district_name_tb, by = "Distrct") %>%
  mutate(District = as.factor(District)) %>%
  select(District, Precnct)
```

To help orient readers as to the locations of the district boundaries,
I also want any maps generated to also display major roads in Howard
County that correspond in whole or in part to district or precinct
boundaries. I use the tigris function `roads()` to return geometry for
all Howard County roads.

Because I don’t need or want to display each and every Howard County
road, I use the RTTYP and FULLNAME variables to filter the results to
retain only major roads (interstate and U.S. highways) and significant
minor roads (Maryland state routes and roads with “Parkway” in their
names). I store the geometry for each in separate variables so that I
can plot them at different widths.

```{r roads}
all_roads <- roads(state = "MD", county = "Howard County", class = "sf", progress_bar = FALSE)

major_roads_geo <- all_roads %>%
  filter(RTTYP %in% c("I", "U")) %>%
  st_geometry()

minor_roads_geo <- all_roads %>%
  filter(RTTYP == "S" | str_detect(FULLNAME, "Pkwy")) %>%
  st_geometry()
```

### Analysis

I plot the new districts along with the major (and some minor) roads
to show how the new districts would relate to existing communities in
Howard County.

Although this was not specified explicitly as part of the
auto-redistricting process, the new districts nicely divide the county
into three "communities of interest":

- Southeastern Howard County, including Savage, North Laurel, most of
  east Columbia south of Route 175, and most of west Columbia except
  the Village of River Hill.
- Northeastern Howard County, including Elkridge, Ellicott City south
  of Route 40, and east Columbia north of Route 175.
- Western Howard County, including Ellicott City north of Route 40 and
  the Village of River Hill in Columbia.

```{r plot}
palette <- c("#E69F00", "#56B4E9", "#009E73")

redistricting_sf %>%
  left_join(new_districts_tb, by = "Precnct") %>%
  ggplot(aes(fill = District, geometry = geometry)) +
  geom_sf(size = 0) +
  scale_fill_manual(values = palette) +
  geom_sf(data = major_roads_geo, color = "white", size = 1.0, fill = NA) +
  geom_sf(data = minor_roads_geo, color = "white", size = 0.5, fill = NA) +
  labs(title="Districts for 15-Member Council with Ranked Choice Voting",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning, 2020 Redistricting Data",
         "\n  Maryland Board of Elections, 2018 General Election Results",
         "\n  Howard County GIS Division, Precinct Boundaries",
         "\nCreated using the Auto-Redistrict application and tidyverse R package"
       )
  ) +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0)) +
  theme(axis.ticks = element_blank(), axis.text = element_blank()) +
  theme(panel.background = element_blank())
```

The precinct-level data in `redistricting_sf` contains population
figures by race. I combine the precinct-level data (in
`redistricting_sf`) with the assignment of precincts to council
districts produced by the Auto-Redistrict application (in
`new_districts_sf`), and then drop the geometry for the precinct
boundaries.

```{r table}
district_data <- redistricting_sf %>%
  left_join(new_districts_tb, by = "Precnct") %>%
  st_drop_geometry()
```

I compute the racial/ethnic breakdowns for each district.

```{r racial}
racial_breakdown <- district_data %>%
  group_by(District) %>%
  summarize(Adj_Ppl = sum(Adj_Ppl),
            Ad_NH_W = sum(Ad_NH_W),
            Ad_NH_B = sum(Ad_NH_B),
            Ad_NH_A = sum(Ad_NH_A),
            Ad_NH_R = sum(Ad_NH_R),
            Adj_H_O = sum(Adj_H_O)) %>%
  mutate(`NH White` = round(100 * Ad_NH_W / Adj_Ppl),
         `NH Black` = round(100 * Ad_NH_B / Adj_Ppl),
         `NH Asian` = round(100 * Ad_NH_A / Adj_Ppl),
         `NH Multiracial` = round(100 * Ad_NH_R / Adj_Ppl),
         Hispanic = round(100 * Adj_H_O / Adj_Ppl)) %>%
  select(District, `NH White`, `NH Black`, `NH Asian`, `NH Multiracial`, Hispanic)
```

I plot the racial/ethnic breakdowns by district. I also draw
horizontal dashed lines representing the quota levels in a five-member
district using ranked choice voting. (For example, if a candidate can
get 16.6% of the first preference votes in a five-member district then
they will automatically be elected. Here 16.6% is the quota.)

```{r ggplot_racial}
palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2")

quota = 100 / 6

racial_breakdown %>%
  gather(key = "Race", value = Vote_Pct, `NH White`:Hispanic) %>%
  mutate(Race = fct_relevel(Race, c("NH White", "NH Black", "NH Asian", "NH Multiracial", "Hispanic"))) %>%
  ggplot(mapping = aes(x = District, y = Vote_Pct, fill = Race)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = palette) +
  geom_hline(mapping = aes(yintercept = quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 2 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 3 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 4 * quota), color = "gray", linetype = "dashed") +
  labs(title="Expanded County Council District Population Percentage By Race",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning, 2020 Redistricting Data",
         "\n  Maryland Board of Elections, 2018 General Election Results",
         "\n  Howard County GIS Division, Precinct Boundaries",
         "\nCreated using the Auto-Redistrict application and tidyverse R package"
       )
  ) +
  ylab("Population (%)") +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0)) +
  theme_bw()
```

I compute the party breakdown for each district.

```{r party}
party_breakdown <- district_data %>%
  mutate(Votes = CEx.DEM + CEx.REP + CCn.DEM + CCn.REP,
         Dem_Votes = CEx.DEM + CCn.DEM,
         Rep_Votes = CEx.REP + CCn.REP) %>%
  group_by(District) %>%
  summarize(Votes = sum(Votes),
            Dem_Votes = sum(Dem_Votes),
            Rep_Votes = sum(Rep_Votes)) %>%
  mutate(Democratic = round(100 * Dem_Votes / Votes),
         Republican = round(100 * Rep_Votes / Votes)) %>%
  select(District, Democratic, Republican)
```

I plot the party breakdowns by district, again adding horizontal
dashed lines to represent the quotas. (For example, if a party’s total
vote share exceeds 33.3%, or two quotas, that party fields two
candidates, and the two candidates have an equal share of first
preference votes, then both candidates will automatically be elected.)

```{r ggplot_party}
palette <- c("#0072B2", "#D55E00")

party_breakdown %>%
  gather(key = "Party", value = Vote_Pct, Democratic:Republican) %>%
  mutate(Party = fct_relevel(Party, c("Democratic", "Republican"))) %>%
  ggplot(mapping = aes(x = District, y = Vote_Pct, fill = Party)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = palette) +
  geom_hline(mapping = aes(yintercept = quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 2 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 3 * quota), color = "gray", linetype = "dashed") +
  geom_hline(mapping = aes(yintercept = 4 * quota), color = "gray", linetype = "dashed") +
  ylab("Estimated Vote (%)") +
  labs(title="Expanded County Council District Estimated Vote by Party",
       subtitle = "Automatically Generated using 2020 Census and 2018 Election Data",
       caption = paste0(
         "Data sources:",
         "\n  Maryland Department of Planning, 2020 Redistricting Data",
         "\n  Maryland Board of Elections, 2018 General Election Results",
         "\nCreated using the Auto-Redistrict application and tidyverse R package"
       )
  ) +
  theme_bw() +
  theme(plot.caption = element_text(margin = margin(t = 15), hjust = 0))
```

## Appendix

### Caveats

See part 1.

### References

See part 1.

### Suggestions for others

See part 1.

### Environment

I used the following R environment in doing the analysis above:

```{r}
sessionInfo()
```

### Source code

You can find the source code for this analysis and others at my
[hocodata public code repository][hd].  This document and its source
code are available for unrestricted use, distribution and modification
under the terms of the [Creative Commons CC0 1.0 Universal (CC0 1.0)
Public Domain Dedication][cc0].  Stated more simply, you’re free to do
whatever you’d like with it.

[hd]: https://github.com/frankhecker/hocodata
[cc0]: https://creativecommons.org/publicdomain/zero/1.0/
